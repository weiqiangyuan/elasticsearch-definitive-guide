[[parent-child]]
== 父-子关系文档

父-子关系文档((("relationships", "parent-child")))((("parent-child relationship")))和
 <<nested-objects,nested model>> 有一个相似点：允许将一个对象实体和另外一个对象实体关联起来。((("nested objects", "parent-child relationships versus")))而这两种类型的主要区别是：在 <<nested-objects,nested model>> 文档中，所有对象都是在同一个文档中，而在父-子关系文档中，父对象和子对象都是完全独立的文档。

父-子关系的主要作用是允许把一个 type 的文档和另外一个 type 的文档关联起来，构成1对n的关系：一个父文档可以对应多个子文档((("one-to-many relationships")))。与 <<nested-objects,`nested` objects>> 相比，父-子关系的主要优势有：

* 更新父文档时，不会重新索引子文档。
* 创建，修改或删除子文档时，不会影响父文档和其他子文档。这一点在这种场景下尤其有用：子文档数量较多，并且子文档创建和修改的频率高时。
* 子文档可以作为搜索结果，独立返回。

Elasticsearch 维护了一个父文档和子文档的映射关系——ID maps，实现了快速的父-子文档查询操作。但是，有一点需要指出：父文档和其所有子文档，都必须要存储在同一个分片中。

ID maps 维护在 <<docvalues>> 中。通过 <<docvalues>>，可以将热点查询的 ID maps 维护在内存中；当 ID maps 变得非常大时，还可以将其扩展加载到硬盘中。



[[parent-child-mapping]]
=== 父-子映射

建立父-子映射关系时需要指定某一个文档 type 是另一个文档 type 的父亲。((("mapping (types)", "parent-child")))((("parent-child relationship", "parent-child mapping")))该关系可以在如下两个时间点设置：1）创建索引时；2）在子文档的 type 创建之前，通过更新父文档的 mapping。

举例说明，有一个公司在多个城市有分公司，并且每一个分公司下面都有很多员工。有这样的需求：按照分公司、员工的维度去搜索，并且搜索某些特定分公司下的员工。针对该需求，用嵌套模型是无法实现的。当然，如果使用 <<application-joins,application-side-joins>> 或者 <<denormalization,data denormalization>> 也是可以实现的。

在这里我们使用父-子文档，首先需要父子文档的映射关系，我们在创建员工 `employee` 文档 type 时，指定分公司 `branch` 的文档 type 为其父亲。

[source,json]
-------------------------
PUT /company
{
  "mappings": {
    "branch": {},
    "employee": {
      "_parent": {
        "type": "branch" <1>
      }
    }
  }
}
-------------------------
<1> `employee` 文档 是 `branch` 文档的子文档。
